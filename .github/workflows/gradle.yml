# .github/workflows/main.yml

name: Java CI with Gradle

on:
  push:
    branches: [ "main" ] # main 브랜치에 푸시될 때 워크플로우 실행
  pull_request:
    branches: [ "main" ] # main 브랜치로 풀 리퀘스트가 생성/업데이트될 때 워크플로우 실행

jobs:
  build:
    runs-on: ubuntu-latest # 최신 Ubuntu 환경에서 빌드 작업 실행
    permissions:
      contents: read # 리포지토리 내용을 읽을 수 있는 권한 부여

    steps:
    - uses: actions/checkout@v4 # GitHub 리포지토리를 워크플로우 러너로 체크아웃
    - name: Set up JDK 17
      uses: actions/setup-java@v4 # JDK 17 설정
      with:
        java-version: '17'
        distribution: 'temurin' # Adoptium Temurin 배포판 사용

    - name: Setup Gradle
      uses: gradle/actions/setup-gradle@v3

    - name: Grant execute permission for gradlew
      # 'gradlew' 파일이 실제 존재하는 하위 디렉토리로 작업 디렉토리를 변경합니다.
      working-directory: ./Back-end
      run: chmod +x gradlew # gradlew 스크립트에 실행 권한 부여

    - name: Build with Gradle Wrapper
      # 'gradlew' 파일이 실제 존재하는 하위 디렉토리로 작업 디렉토리를 변경합니다.
      working-directory: ./Back-end
      run: ./gradlew build # Gradle Wrapper를 사용하여 프로젝트 빌드

    # 빌드된 JAR 파일을 아티팩트로 업로드합니다.
    - name: Upload JAR artifact
      uses: actions/upload-artifact@v4
      with:
        name: spring-boot-app # 아티팩트 이름
        path: ./Back-end/build/libs/*.jar # 빌드된 JAR 파일의 경로
        retention-days: 1 # 아티팩트 보존 기간 (선택 사항)

  deploy:
    runs-on: ubuntu-latest # 최신 Ubuntu 환경에서 배포 작업 실행
    needs: build # 'build' 작업이 성공해야만 이 'deploy' 작업이 실행됩니다.
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    permissions:
      contents: read # 리포지토리 내용을 읽을 수 있는 권한 부여

    steps:
      # 1. 빌드 잡에서 업로드한 아티팩트(JAR 파일)를 다운로드합니다.
      - name: Download JAR artifact
        uses: actions/download-artifact@v4
        with:
          name: spring-boot-app # 업로드했던 아티팩트 이름과 동일
          path: ./ # 현재 작업 디렉토리(./)로 다운로드

      # 2. SCP를 사용해 EC2 서버로 JAR 파일을 복사합니다.
      - name: Copy JAR to EC2
        uses: appleboy/scp-action@v0.1.4
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USERNAME }}
          key: ${{ secrets.EC2_SSH_KEY }}
          port: 22
          source: "*.jar" # 현재 디렉토리의 모든 .jar 파일을 전송
          target: "/home/ubuntu/app" # EC2의 배포 경로

      # 3. SSH로 EC2에 접속해 배포 스크립트를 실행합니다.
      - name: Deploy Spring Boot App on EC2
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USERNAME }}
          key: ${{ secrets.EC2_SSH_KEY }}
          port: 22
          script: |
            # EC2 서버에서 실행될 스크립트
            DEPLOY_PATH="/home/ubuntu/app"
            cd ${DEPLOY_PATH}

            echo "🔥 기존 Spring Boot 애플리케이션을 종료합니다 (포트 8080)..."
            PID=$(sudo lsof -t -i:8080)
            if [ -n "$PID" ]; then
              echo "   PID ${PID}를 종료합니다."
              sudo kill -9 "$PID"
            else
              echo "   8080 포트에서 실행 중인 애플리케이션이 없습니다."
            fi

            echo "🔄 새로운 JAR 파일로 교체합니다."
            # 기존 app.jar 삭제
            rm -f app.jar
            # 방금 SCP로 복사된 최신 JAR 파일의 이름을 app.jar로 변경
            NEWEST_JAR=$(ls -t *.jar | head -n 1)
            if [ -z "$NEWEST_JAR" ]; then
              echo "❌ 배포할 JAR 파일을 찾을 수 없습니다."
              exit 1
            fi
            mv "${NEWEST_JAR}" app.jar

            echo "🚀 새로운 Spring Boot 애플리케이션을 시작합니다..."
            # nohup으로 백그라운드 실행 및 로그 리디렉션
            nohup java -jar app.jar > /dev/null 2>&1 &

            echo "✅ 배포 완료! 애플리케이션이 백그라운드에서 실행됩니다."
